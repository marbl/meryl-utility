----------------------------------------------------------------------
FastASequenceInCore

A lot of public methods, but only these are *really* public methods.
They should be self-explanatory.

char           *header(void) const;
u32bit          headerLength(void) const;

char           *sequence(void) const;
u32bit          sequenceLength(void) const;

u32bit          getIID(void) const;


----------------------------------------
FastAFile(const char *filename);

Create a new wrapper, given a path name.  If the filename is 0L or "-", stdin is opened.


----------------------------------------
void         openIndex(u32bit indextypetoload, const char *indexname);
void         openIndex(const char *indexname=0L);
void         openIndex(u32bit indextypetoload);

Open (creating if needed) an index file.  The index types are
        FASTA_INDEX_ANY           - open any index file
        FASTA_INDEX_ONLY          - open/create an iid-only index
        FASTA_INDEX_PLUS_IDS      - open/create an index for iid's and names
        FASTA_INDEX_PLUS_DEFLINES - open/create an index for iid's and deflines

If an index exists for a type greater than the one specified, the
index is opened as the type specified.  For example, if a
FASTA_INDEX_PLUS_DEFLINES index exists, but the user requests that a
FASTA_INDEX_ONLY be opened, then the index is opened as a
FASTA_INDEX_ONLY.

Exception: If a FASTA_INDEX_PLUS_DEFLINES is opened as a
FASTA_INDEX_PLUS_IDS, the full defline is available, not just the
name.

If indexname is not supplied, it defaults to ${filename}idx.

If no type is specified, it defaults to FASTA_INDEX_ANY if the index
exists, or FASTA_INDEX_ONLY if no index exists.


----------------------------------------
bool         isRandomAccess(void)

Returns true if the file is opened for random access.


----------------------------------------
bool  &loadSequencesIntoMemory(void);

If true, sequences will be loaded into memory.  If false, sequences
will remain on disk, with only a small buffer in memory.  Defaults to
true.  Currently has no effect -- all sequences are in memory.


----------------------------------------
FastASequenceInCore *getSequence(void);

Returns a FastASequenceInCore object.  The file pointer is moved to
the next available sequence; the next call to getSequence() will
return the next sequence in the file.  Returns 0L if no valid sequence.


----------------------------------------
u32bit          sequenceLength(IID_t iid);
u32bit          headerLength(IID_t iid);

If an index exists, return the lengths for some sequence iid.  Otherwise, returns 0.


----------------------------------------
u32bit          currentIID(void);

Returns the iid of the sequence we will get by calling getSequence().
For example:
        currentIID()  -> returns i
        getSequence() -> returns sequence iid=i
        currentIID()  -> returns i+1


----------------------------------------
bool         eof(void);

Returns true if the end of file has been reached.


----------------------------------------
bool         find(IID_t  iid);
bool         find(char  *id);

Moves the file pointer to the start of the specified sequence.  All
index files can use find(IID_t); only name and deflines indexes can
use find(char*).  Returns true if the sequence was located.


----------------------------------------
u32bit       getNumberOfSequences(void);

If an index exists, returns the number of sequences in the file, otherwise, returns 0.


----------------------------------------
const char  *getSourceName(void);

Returns the name of the sequence source.




